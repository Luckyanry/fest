{"version":3,"sources":["js/kinetic/index.js","../node_modules/global/window.js","../node_modules/is-function/index.js","../node_modules/parse-headers/parse-headers.js","../node_modules/xtend/immutable.js","../node_modules/xhr/index.js","../node_modules/parse-bmfont-ascii/index.js","../node_modules/parse-bmfont-xml/lib/parse-attribs.js","../node_modules/xml-parse-from-string/index.js","../node_modules/parse-bmfont-xml/lib/browser.js","../node_modules/parse-bmfont-binary/index.js","../node_modules/base64-js/index.js","../node_modules/ieee754/index.js","../node_modules/isarray/index.js","../node_modules/buffer/index.js","../node_modules/buffer-equal/index.js","../node_modules/load-bmfont/lib/is-binary.js","../node_modules/load-bmfont/browser.js","../node_modules/word-wrapper/index.js","../node_modules/as-number/index.js","../node_modules/layout-bmfont-text/index.js","../node_modules/inherits/inherits_browser.js","../node_modules/dtype/index.js","../node_modules/an-array/index.js","../node_modules/is-buffer/index.js","../node_modules/quad-indices/index.js","../node_modules/three-bmfont-text/lib/vertices.js","../node_modules/three-bmfont-text/lib/utils.js","../node_modules/three-bmfont-text/index.js","../node_modules/object-assign/index.js","../node_modules/three-bmfont-text/shaders/msdf.js","js/kinetic/Type.js","js/kinetic/shaders.js","js/kinetic/options.js","js/script.js"],"names":["renderer","THREE","WebGLRenderer","alpha","setPixelRatio","Math","min","window","devicePixelRatio","setSize","innerWidth","innerHeight","setClearColor","elWidth","elHeight","console","log","camera","PerspectiveCamera","position","z","scene","Scene","clock","Clock","init","render","requestAnimationFrame","animate","bind","i","children","length","obj","updateTime","getElapsedTime","addEventListener","resize","addToDom","canvas","domElement","container","document","querySelector","appendChild","kineticWrap","width","height","aspect","updateProjectionMatrix","module","exports","extend","hasOwnProperty","Object","prototype","target","arguments","source","key","call","Buffer","require","a","b","isBuffer","undefined","equals","dtype","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Float32Array","Float64Array","Array","Uint8ClampedArray","getOwnPropertySymbols","propIsEnumerable","propertyIsEnumerable","toObject","val","TypeError","shouldUseNative","assign","test1","String","getOwnPropertyNames","test2","fromCharCode","order2","map","n","join","test3","split","forEach","letter","keys","err","from","to","symbols","s","options","opts","word","color","fill","wordPosition","texture","wordScale","scale","mesh","rotation","geometry","vertex","shaders","fragment","fontFile","font","file","fontAtlas","atlas","fontGeometry","text","loader","TextureLoader","load","fontMaterial","RawShaderMaterial","side","DoubleSide","transparent","negate","createRenderTarget","createMesh","rt","WebGLRenderTarget","rtCamera","rtScene","background","Color","Mesh","set","PI","add","material","ShaderMaterial","vertexShader","fragmentShader","uniforms","uTime","value","uTexture","defines","lookAt","Vector3","onBeforeRender","setRenderTarget","Gl","time","Object3D","torusVertex","torusFragment","TorusKnotGeometry","App","createGl","angle","radius","x","cos","sin","type","Type","$","click","toggleClass","smoothAnchors","querySelectorAll","anchor","e","preventDefault","anchorID","getAttribute","scrollIntoView","top","behavior"],"mappings":"AuBAA,AJAA,ARAA,AWAAkD,AVAA,ASAA,AGAA,AtBAA,AWAA,AOAA,ASAA,AvBAA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJAAA,MkBAM,AlBAA,CkBACC,AlBAAA,OkBAP,AlBAA,GkBAiB,AlBAAC,MAAjB,IkBA0BgB,KAAT,EAAgB;ACCjC,AJAA,ARAA,AIDA,AOCE,ArBDF,AWCA,ASAA,AGAA,AtBAA,AWAA,AOAA,AHDA,ADAA,AVCA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCA,IWFIP,AXEAR,MWFM,AOCAe,GPDGN,EOCX,GlBCgB,EWFE,CAAC,AXEAR,MAAM,CAACC,CWFR,CAAP,CAAkBM,MAA/B,AXEqB,CAAiBR,CWFC,aXEvC;AmBAA,AJAA,ARAA,AGFA,AQEI,ArBDJ,AWCA,ASAA,AGAA,AtBAA,AWAA,AOAA,AHDA,ADAA,AVCA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,A0BOA,SZPS,MAAL;ACCJ,AJAA,ARAA,AGFA,AQEM,ArBDN,AWCA,ASAA,AGAA,AtBAA,AWAA,AOAA,AHDA,ADAA,AVCA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCA,SAASD,IkBDIiB,ElBCb,GAAkB,IkBDZ;ACCN,AJAA,ARAA,AIFAnB,ADAA,AbCA,AWCA,ASAA,AGAA,AtBAA,AWAA,AOAA,AHDA,ADAA,AVCA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCI,A8BKJ,MnBRM,AXGEM,CWHDL,KXGO,EWHd,CXGiB,EWHA,AXGb,UWHuBY,CAAV,EAAaC,CAAb,EAAgB;AQGjC,AZAA,AIFI,ADAJ,AQCI,ArBAJ,AWCA,ASAA,AGAA,AtBAA,AWAA,AOAA,AHDA,ADAA,AaEA,AvBDA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,MOFQ,CAACH,EOCA,IPDM,CAACI,EOCZ,MPDK,CAAgBF,CAAhB,CAAL,EAAyB,OAAOG,SAAP;AQG7B,AZAA,AIFI,ADAJ,AQCM,ArBAN,AWCA,ASAA,AGAA,AtBAA,AkBAA,AHDA,ADAA,AaEA,AvBDA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCI,A4BPJ,MjBIQ,CAACL,AXGA,IAAI/B,CAAC,CWHC,AOCFwC,CPDGL,CXGC,CAAb,EAAgBnC,CAAC,GWHZ,AXGe2B,CWHCO,AOCnB,CPDG,CAAL,EAAyB,IXGI,CAAChC,EWHEkC,IXGhC,EAAsCpC,CAAC,EWHd,AXGzB,EAA2C;AmBA/C,AZAA,AIFI,ADAJ,AbCA,AWCA,ASAA,AGAA,AtBAA,AkBAA,AHDA,ADAA,AVCA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCQ,A2BRR,AEAA,ADEA,IAAMuI,EjBGE,EXGI3G,KWHGK,CAAC,AXGE,CWHDI,AiBHA,E5BMIV,IWHb,KAAoB,AXGE,CAAC3B,CAAD,CAAtB,OWHJ,EAAoC,OAAOiC,CAAC,CAACI,MAAF,CAASH,CAAT,CAAP;AQGxC,AZAA,AIFI,ADAJ,AQAI,ArBCJ,AWCA,ASAA,AGAA,AtBAA,AkBAA,AHDA,ADAA,AaCA,AvBAA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AwBNoB,IHMhBe,EdFIhB,CAAC,CAAC/B,COAD,KPAD,EOAJ,GPAiBgC,CAAC,CAAChC,IcEE,EdFrB,CcEwBsB,CdFG,KcEG,CAACyB,CdFG,KAAP,ecE/B;ANCA,AZAA,AGFA,AQAM,ArBCN,AWCA,ASAA,AGAA,AtBAA,AkBAA,AHDA,AYCA,AvBAA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCQ,A2BPR,AEFA,ADCiB,IHOb1B,KzBCS,IkBHAkB,AlBGIZ,GAAT,EyBDU,EzBCMD,CyBDHJ,EPFf,GlBGE,CyBDmB,CAACC,AzBCI,SyBDX,CAAiBF,cAAtC,0KGPA;ATQA,AZAA,AIFI,ADAJ,AbCA,AWCA,ASAA,AGAA,AtBAA,AkBAA,AHDA,AYCA,AvBAA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCY,A4BKZ,IHNI2B,AGMEsF,GjBRG,GXGOjH,CWHHvB,CAAC,GAAG,CAAb,CiBQe,CjBRCA,CAAC,CcED,EdFIiC,CAAC,AcEFT,CdFGtB,AXGI,CAAC4B,IyBDF,AzBCb,CWHZ,AcE0BL,AzBCMG,EWHF5B,CAAC,EAA/B,CXGY,CWHuB,CXGK6B,CyBDrB,CAAiBsB,CzBCxB,CAAJ,EAAsC,gByBDlD;ANCA,AZAA,AIFQ,ADAR,AQDI,ArBEJ,AWCA,ASAA,AGAA,AtBAA,AkBAA,AHDA,AXCA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCgBzB,A2BRhB,AEFA,ADcsB,QjBPVO,AXGIP,CWHH,AODJ,CPCK1B,CAAD,CAAD,EXGU,CAAC6B,CkBJnB,CPCiBK,CAAC,AXGA,CWHClC,AXGP,CWHM,CAAd,CXGsB4B,CWHH,KXGS,CAACC,CWHH,EXGE,CAApB,EWHW;AJG3B,AIFK,ADAL,AQDM,ArBEN,AWCA,ASAA,AGAA,AtBAA,AkBAA,AHDA,AYCA,AvBAA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCa,A4BGM,SHJVuB,IPHIV,IOGb,CAAkBW,GAAlB,EPHM,AOGiB,odGIvB;ArBHA,AGFA,AbCA,AWCA,ASAA,AGAA,AtBAA,AkBAA,AHDA,AYCC,AvBAD,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCS,A2BTT,MFQKA,GAAG,KAAK,C7BbE,AgCsCA,GHzBV,IAAgBA,GAAG,KAAKjB,SAA5B,EAAuC;AlBCxC,AIFI,ADAJ,AQFI,ArBGJ,AWCA,ASAA,AGAA,AtBAA,AkBAA,AHDA,AYCE,AvBAF,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCK,AJdH,AgCqCemG,EAAAA,OjB1BN,AOFF,COID,GdFJ,AiB0BwB,CHxBhBjF,CGwBKiF,EV5Bb,GtBTY,G6BaR,CAAc,EGwBP,qDHxBP,CAAN;AlBCF,AIFC,ADAD,AQFM,AVIN,ASAA,AGAA,AtBAA,AkBAA,AHDA,AYCE,AvBAF,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AuBTA,A/BLgB,AiCGhB,ADkC8BC,CjBpC9B,CiBoC8BA,EClCxB5D,OAAO,EXOAjC,CWPG,CACd,ADiCyC,EAAb6F,OV3BxB;AXKN,AGFA,AFEA,ASAA,AGAA,AtBAA,AkBAA,AHDA,AXCA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCI,A6BXA1D,ADgCW,EChCXA,IAAI,EAAE,C7BWCpD,MAAP,E6BZF;AtBYF,AGFA,AQHI,AVKJ,ASAA,AGAA,AtBAA,AkBAA,AHDA,AYCC,AvBAD,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,AJCC,A2BXD,A/BLI,AiCKAqD,EAAAA,KAAK,EXKA,AOKDvD,A7BfCtD,AiCKE,MJUG,CAACmF,CPLX,AtBVA,CiCGF,CJYY,CAAb,A7BfmB,IAAIlF,KAAK,CAACC,aAAV,CAAwB;AWgB5C,AGFA,AQHM,AVKN,ASAA,AGAA,AtBAA,AkBAA,AHDA,AYCC,AvBAD,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,ARfMC,AiCKF2G,EAAAA,IjCLE3G,AiCKE,EAAE,GjCLC,EsBUEuE,AtBVA,IiCEX,OXQI;AXMN,AGFA,AFEA,ASAA,AGAA,AJAA,AHDA,AXCA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,ARjB4C,AiCOxC2C,EAAAA,GjCPgB,CAAhB,IiCOQ,EAAE,IAAIpH,KAAK,CAACsK,iBAAV,CAA4B,CAA5B,EAA+B,CAA/B,EAAkC,GAAlC,EAAuC,CAAvC,EAA0C,CAA1C,EAA6C,CAA7C,CAJZ;AtBeF,AGFA,AQJI,AVMJ,ASAA,AGAA,AJAA,AHDA,AYCA,AvBAA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,ARfI,AiCKApJ,EAAAA,ECCEqJ,KZGG,AOMAnF,A7BfArF,CiCKG,EAAE,KjCLV,CsBSA,AtBTcI,M6BelB,GAA2B,I7BfvB,CAA4BC,IAAI,CAACC,GAAL,CAASC,MAAM,CAACC,gBAAhB,EAAkC,GAAlC,CAA5B;AWgBJ,AGFA,AQJM,AVMN,ASAA,AGAA,AJAA,AHDA,AYCC,AvBAD,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,ARfI,AiCKEwG,ACCJ,IDDIA,EJUD,G7BfIhH,EiCKI,EXIA2E,AWJE,CAAC,CAAC,EjCLb,AkCMY,ClCNElE,EiCKH,EAAS,CAAC,EXInB,AtBTF,CAAsBF,AiCKX,EAAe,CAAf,CADD,EjCJkB,CAACG,UAA7B,EAAyCH,MAAM,CAACI,WAAhD;AWgBJ,AGFA,AFEA,ASAA,ADAA,AHDA,AYCE,AvBAF,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,ARfI,AiCKEwG,ACAU,IDAVA,IJUA,AIVI,CJUH7D,A7BfEtD,CiCKG,CAAC,CAAD,EAAI,CJUH,AIVD,CJUEsF,C7BfV,AiCKe,CjCLD1E,AiCKN,IJUV,EAAoB,O7BflB,CAA4B,QAA5B,EAAsC,CAAtC;AWgBJ,AGFA,AQLI,AVOJ,ASAA,ADAA,AHDA,AYCG,AvBAH,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,ARdI,AiCCU,GALZ,KjCIMC,CsBOC,IOOC,E7BdK,GsBOX,AOOD,A7BdeN,MAAM,CAACG,UAAP,GAAoB,CAAlC;AWeJ,AGFA,AQLM,AVON,ASAA,ADAA,AHDA,AYCG,AvBAH,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,ARdI,AiCIAwG,ACDA,EDCAA,GJOC,CAKH,CIZO,CjCJDpG,CiCIG,ACDFW,CDCG,GXGCmD,AYJT,CDCO,EjCJK,AiCIE,GjCJCrE,CiCIR,EAAa,CAAb,CATT,CXYI,AtBPmB,CAACI,WAAP,GAAqB,CAApC;AWeJ,AGFA,AFEA,ASAA,ADAA,AHDA,AYIE,AvBHF,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,ARbII,AiCGAwG,ACDD,EDCCA,EjCHAxG,KiCGO,EjCHA,AiCGE,CjCHDC,GAAR,CAAYH,OAAZ,EAAqBC,QAArB;AWcJ,AGFA,AQNI,AVQJ,ASAA,ADAA,AHDA,AXCA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,ARZI,AiCEEwG,IAAAA,KXEG,AtBJArG,CiCEG,EAAEsG,GjCFV,CsBIA,EtBJc,IAAItH,KAAK,CAACiB,CiCENmJ,WADT,KjCDK,CAA4B,EAA5B,EAAgCxJ,OAAO,GAAGC,QAA1C,EAAoD,CAApD,EAAuD,IAAvD,CAAd;AWaJ,AGFA,AQNM,AVQN,ASAA,ADAA,AHDA,AXCA,AIAA,ADAA,AFAA,AJAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,AGAA,ARXI,AiCCE0G,IAAAA,KjCDGvG,GiCCK,CXED4D,CWFG0C,CjCDZ,CAAYpG,EsBGV,MtBHF,CAAqBC,CAArB,GAAyB,CAAzB,CiCCoBkJ;AtBWxB,AGFA,AFEA,AQAA,AHDA,AYEE,AvBDF,AIAA,ADAA,ANAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,ALXI,AiCFS,GAVX,KJwBI/E,C7BZGlE,I6BYE,C7BZP,E6BYU,C7BZG,G6BYCmE,C7BZGvF,K6BYP,A7BZY,C6BYD,A7BZEqB,K6BYb,A7BZG,C6BYf,CARG,A7BJD,C6BY8B;AlBAlC,AGFA,AQPI,AVSJ,AQAA,AHDA,AXCA,AIAA,ADAA,ANAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,ALXI,AiCCAoG,EAAAA,IAAI,EAAE,CXCD,AtBFAnG,KAAL,GAAa,IAAItB,GsBEjB,EtBFsB,CAACuB,AkCFlB,KlCEQ,EAAb;AWYJ,AGFA,AQPM,AVSN,AQAA,AHDA,AYCE+D,AvBAF,AIAA,ADAA,ANAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,ALVI,AiCAEoC,ACHF,ILaFpC,AIVIoC,IAAI,CJUH,A7BVElG,C6BUD,AIVIgG,CJUL,AKbEgD,CLaP,CPTW3F,AtBDT,E6BUS,IAAX,AKbE,WZIE,EWFI;AtBYV,AGFA,AQ5BE,AV8BF,AQAA,AHDA,AXCA,AIAA,ADAA,ANAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,ALVG,AiCAG+C,ACHH,IDGGA,KAAK,EAAED;AtBWb,AGFA,AQPC,AVSD,AQAA,AHDA,AYAE,AvBCF,AIAA,ADAA,ANAA,AsBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,A4BbU,CXnBV,OO+BMtE,MAAM,CAACmC,mBAAP,CAA2BF,KAA3B,EAAkC,CAAlC,MAAyC,GAA7C,EAAkD;AlBEpD,AGFA,AFEA,AQAA,AHDA,AYAG,AvBCH,AIAA,ADAA,AgBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,ALjCe,AiCKb,CADc,CAAhB,WJ4BU,KAAP;AlBEH,AGFA,AFEA,AQAA,AHDA,AYAG,AvBCH,AIAA,ADAA,AgBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,ALlCe,K6BqBV,CAcH,SITamB,gBCNF;AvBeb,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AgBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,ALnCe,AkCqBX,WAAK,IAAI5E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4E,GlCEb,ckCFqB1E,MAA5B,EAAoCF,CAAC,EAArC,EAAyC;AvBe7C,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AgBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,ALZI,AkCFE,WlCEG9B,QAAL,CAAc0B,MAAd,CAAqB,KAAKL,KAA1B,EAAiC,KAAKJ,MAAtC;AWaJ,AGFA,AFEA,AQAA,AHDA,AYAE,AvBCF,AIAA,ADAA,AgBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,ALZG,AkCFG,QLaAyE,IKbIgF,CLaC,GAAG,CKbC,CLab,EKbiB5I,CAAC,GAAG4E,iBAAQ1E,MAAb,IAAwB3B,IAAI,CAAC8I,EAAL,GAAU,CAAlC,IAAuC9I,IAAI,CAAC8I,EAAL,GAAU,GAA7D,CAFuC,CAE0B;AvBevE,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AgBAA,AGAA,ADAA,ADAA,AIAA,AZAA,AbAA,ALtCe;AWuCf,AGFA,AFEA,AQAA,AHDA,AYDE,AvBEF,AIAA,ADAA,AgBAA,AGAA,AFAA,AIAA,AZAA,AbAA,ALvCe,AkCwBT,SLaC,GKbGwB,CLaC7I,CAAC,GAAG,CAAb,AKbc,ELaEA,CAAC,AKbA,EAAb,CLagB,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;AlBG/B,AGFA,AFEA,AQAA,AHDA,AYDG4D,AvBEH,AIAA,ADAA,AgBAA,AGAA,AFAA,AIAA,AZAA,AbAA,ALxCe,AkCyBT,MLaHA,KAAK,CAAC,AKbCkF,CAAC,GAAGD,ELaCnF,IKbK,ELaC,CAACG,AKbCtF,IAAI,ClCEf,AkCFgBwK,GAAL,CAASH,GLajB,CAAoB5I,CAApB,AKbQ,CLaf,AKbF,CLaH,GAAsCA,CAAtC;AlBGH,AGFA,AFEA,AQAA,AHDA,AYDG,AvBEH,AIAA,ADAA,AgBAA,AGAA,AFAA,AIAA,AZAA,AbAA,ALbIH,AkCFE,MlCEFA,MkCFMP,CAAC,GAAGuJ,MAAM,GAAGtK,ElCEE,CAAC,CkCFC,CAACyK,GlCEGlJ,AkCFR,CAAS8I,KAAT,ClCEG,AkCFpB,ClCEiC7I,IAAb,CAAkB,IAAlB,CAAD,CAArB;AWcJ,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,A6BfM6E,yBAAQ5E,CAAR,EAAWX,QAAX,CAAoBgG,IAApB,GAA2B,CAACyD,CAAD,EAAI,CAAJ,EAAOxJ,CAAP,CAA3B,CANuC,CAQvC;AvBcN,AGFA,AFEA,AQAA,AHDA,AYFE,AvBGF,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALbI,Q6BUEwE,G7BVG,G6BUG,C7BVC9D,CAAC,C6BUCwB,E7BVE,CAAb,EAAgBxB,C6BUC,A7BVA,C6BUC2D,E7BVE,KAAKpE,KAAL,CAAWU,M6BUpB,CAA2B2D,C7BVlB,CAAoB1D,G6BU7B,EAAkC6D,C7BV7C,E6BUW,A7BVqC/D,C6BUC,A7BVA,EAAjD,EAAqD,M6BUMgE,CAAV,EAAa;AlBIlE,AGFA,AFEA,AQAA,AHDA,AYFG,AvBGH,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALbM,AkCDA,YlCCM7D,AkCDF8I,CLWArF,E7BVK,CkCDD,ELWC,A7BVG,C6BUFI,AKXC,CLWF,CAAZ,E7BVoBzE,AkCDF2J,KlCCH,CAAWjJ,OkCDZ,ClCCC,CAAoBD,AkCDhC,ClCCY,CAAZ;AWcN,AGFA,AFEA,AQAA,AHDA,AYFG,AvBGH,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALbMG,AkCDA8I,KLSS,CAAb,E7BRI9I,AkCDA8I,GlCCG,CAAC7I,AkCDA,CAACT,IAAL,CAAUiF,IlCCV,CAAe,KAAKnF,KAAL,CAAWY,CkCDRL,CAAR,CAAV,WlCCe,EAAf;AWcN,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALbK,AkCDA;AvBeL,AGFA,AFEA,AQAA,AHDA,AYHE,AvBIF,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,A6BdG,QLUG8D,MAAM,CAACG,IAAP,CAAY,EAAZ,MAAoB,YAAxB,EAAsC;AlBKxC,AGFA,AFEA,AQAA,AHDA,AYHG,AvBIH,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALbI,WAAKrE,E6BSC,I7BTN,C6BSD;AlBKH,AGFA,AFEA,AQAA,AHDA,AYHG,AvBIH,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALbG,K6BfE,CA0BH;AlBGF,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALlDe;AWmDf,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALnDe;AWoDf,AGFA,AFEA,AQAA,AHDA,AYHE,AvBIF,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALpDe,Q6BgDTsE,KAAK,GAAG,EAAZ,c7BVY;AWed,AGFA,AFEA,AQAA,AHDA,AYHE,AvBIF,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALdIzF,AkCHJ,IAAIiK,ElCGAjK,CkCHJ,KlCGU,CAAC6B,c6BUc6D,E7BVrB,CAAwB,E6BU1B,CAA6B,EAA7B,EAAiCC,C7BV/B,EAAkC,I6BUpC,CAAyC,A7BVA7D,MAAL,CAAYR,G6BUGsE,C7BVf,CAAiB,I6BUZ,A7BVL,CAAlC,C6BUyD;AlBK7D,AGFA,AFEA,AQAA,AHDA,AYHGH,AvBIH,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALdG,AkCFH,MLYGA,KAAK,CAACG,MAAD,CAAL,GAAgBA,MAAhB;AlBKH,AGFA,AFEA,AQAA,AHDA,AYHG,AvBIH,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALvDe,K6BiDb;AlBOF,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALxDe,AkCuCf8E,CAAC,CAAC,cAAD,CAAD,CAAkBC,KAAlB,CAAwB,YAAW;AvBkBnC,AGFA,AFEA,AQAA,AHDA,AYJE,AvBKF,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALzDe,AkCwCbD,EAAAA,CAAC,CAAC,ILYE3H,AKZH,CAAD,CAAQ6H,ILYE,CAAC/E,IAAP,CAAY9C,CKZhB,CAAoB,ILYE,CAACgC,A7BVhB,IkCFP,ELYgB,CAAc,EAAd,EAAkBU,KAAlB,CAAZ,EAAsCD,IAAtC,CAA2C,EAA3C,MACF,sBADF,EAC0B;AlBK5B,AGFA,AFEA,AQAA,AHDA,AYHG,AvBIH,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALfI,AkCFH,CAFD,UlCISzD,E6BWC,KAAP,C7BXC;AWgBJ,AGFA,AFEA,AQAA,AHDA,AYHG,AvBIH,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALfI,AkCDJ,WlCCSV,OAAL,GAFK,CAGL;AWeJ,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,ALdG;AWeH,AGFA,AFEA,AQAA,AHDA,AYHE,AvBIF,AIAA,ADAA,AmBAA,AFAA,AIAA,AZAA,AbAA,AL7De,AkC6Cf,IAAMwJ,OLYG,IAAP,EKZiB,GAAG1I,QAAQ,CAAC2I,gBAAT,CAA0B,YAA1B,CAAtB;AvBiBA,AGFA,AFEA,AQAA,AHDA,AYHE,AvBIF,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,AL9De,G6BqBd,CAqCE,OAAOhF,GAAP,EAAY;AlBKf,AGFA,AFEA,AQAA,AHDA,AYHE,AvBIF,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,AL/De,+BAgDF,YkCDM+E;AvBiBnB,AGFA,AFEA,AQAA,AHDA,AYHE,AvBIF,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,ALfI,UAAM7I,C6BWD,KAAP,A7BXc,GAAG,KAAKvC,QAAL,CAAcwC,UAA7B;AWgBJ,AGFA,AFEA,AQAA,AHDA,AYHE,AvBIF,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,ALfI,UAAMC,SAAS,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAlB;AWgBJ,AGFA,AFEA,AQAA,AHDA,AYHC,AvBID,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,ALfIF,MAAAA,SAAS,CAACG,WAAV,CAAsBL,MAAtB;AWgBJ,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,ALfG;AWgBH,AGFA,AFEA,AQAA,AHDA,AYHAW,AvBIA,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,ALpEe,M6BgET,CAACC,CKjBEmI,MLiBT,GAAiBjG,QEtDVqB,OFsDyB,EEtDhB,GFsDqBpD,MAAM,CAACgC,MAAZ,GAAqB,UAAU9B,MAAV,EAAkBE,MAAlB,EAA0B;AlBK/E,AGFA,AFEA,AQAA,AHDA,AYHC,AvBID,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,A0B3DgB,A/BVD,AkCgDb4H,IAAAA,ELiBGhF,IAAJ,AKjBO,CAAClE,gBAAP,CAAwB,OAAxB,EAAiC,UAASmJ,CAAT,EAAY;AvBsB/C,AGFA,AFEA,AQAA,AHDA,AYHC,AvBID,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,ALtEe,AkCiDXA,MLiBChF,AKjBDgF,CAAC,CLiBE,AKjBDC,GLiBItG,QAAQ,CAAC1B,EKjBf,ILiBc,CAAjB,E7BZU;AWiBX,AGFA,AFEA,AQAA,AHDA,AYHC,AvBID,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,A0B5DI,A/B4CA,AkCLA,MLiBCgD,I7BZG3D,AkCLE4I,CHvCD9E,EFwDR,EExDG,GAAY,AGuCE,GlCKC,AkCLE2E,GlCKC5I,GkCLK,CAACgJ,IlCKE,CAAC/I,OkCLV,CAAoB,KlCKnB,CAAuB,AkCLxB,CAAjB,iBlCKkB,CAAlB;AWiBJ,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,A0B5DMiE,A/B4CF,AkCJAlE,MAAAA,EHxCEkE,E/B4CE9D,E+B5CE,EAAE4D,AGwCA,ClCIC,AkCJA/D,GlCIGE,G+B5CG,CAAC+D,IADJ,EGyCZ,ClCIuB,AkCJA6E,ClCIC/K,OkCJxB,EAAiCiL,ClCIrB,GAAyB,CAArC,SkCJA,CAAgD;AvBqBpD,AGFA,AFEA,AQAA,AHDA,AYHC,AvBID,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,A0B5DM9E,A/B4CF,AkCJE+E,OLgBA,CExDA/E,AGwCA+E,ElCIE7I,C6BYE0D,AKhBD,CLgBE,CExDA,AGwCA,ELgBG,AExDDC,AGuCuC,CLiBnD,A7BZa,E6BYGD,CAAC,A7BZD5D,G6BYIY,AExDD,CAACoD,KAFL,E/B8CY,C6BYE,A7BZDlG,C6BYEqB,MAA9B,EAAsCyE,CAAC,C7BZvB,C6BYhB,EAA2C,A7BZD,CAAvC;AWiBJ,AGFA,AFEA,AQAA,AHDA,AYHEH,AvBIF,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,A0B5DMQ,A/B6CF,AkCLE+E,ILgBJvF,IAAI,AExDAQ,AGwCA+E,GLgBGvI,A7BXArC,C+B7CC,EAAEyF,EGwCE,CLgBC,A7BXX,C6BWYjD,A7BXAT,AkCLA,GHxCG,CAAC8D,E/B6ChB,E+BhDY,CF2DS,A7BXAhE,C6BWC2D,CAAD,CAAV,CAAb,C7BX4B,GAAG1D,MAA7B;AWgBJ,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,A0B5DMgE,A/B6CF,AkCRgD,OAAhD,CHrCEA,G/B6CG9F,MAAL,CAAYgC,E+B7CE,EAAEyD,OAAO,CAACvF,QAAR,CAAiB6F,C/B6CjC,M+BjDY;ApBiEhB,AGFA,AFEA,AQAA,AHDA,AYHE,AvBIF,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,A0B5DMC,A/B6CF,AkCLD,KARD,GHhCIA,CFwDC,E7BXEjH,E6BWE2D,GAAT,CExDa,EAAE+C,A/B6Cb,C6BWcJ,A7BXA7F,I6BWhB,EAAsB,AExDA,CAACyG,A/B6CrB,CAAsBpE,I+BlDV,C/BkDZ,EAA6BC,MAA7B;AWgBJ,AGFA,AFEA,AQAA,AHDA,AYHG,AvBIH,AIAA,ADAA,AmBAA,AFAA,ARAA,AbAA,A0B5DM5B,A/B6CH,Q+B7CGA,EFwDCkC,MExDO,EAAEqD,MFwDK,CAAC9C,AExDC,CAACzC,GFwDjB,CAAoBmF,IAApB,AExDS,CAAiBa,CFwDAxD,GAA1B,AE9DS,CF8Db,EAAoC;AlBKvC,AGFA,AFEA,AQAA,AHDA,AYHI4C,AvBIJ,AIAA,ADAA,AmBAA,AVAA,AbAA,A0B5DMa,A/BlBS,Q6B0EXb,AExDEa,EFwDA,CAACzD,GAAD,CAAF,CExDU,EFwDA2C,AExDEI,IFwDE,CAAC/C,EExDI,CFwDL,AExDMyD,CFwDpB,OExDY,IAAoB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAPpB;ApBoEhB,AGFA,AFEA,AQAA,AHDA,AYHI,AvBIJ,AIAA,ADAA,AmBAA,AVAA,AbAA,A0B5DMC,AG4BN,QH5BMA,QAAQ,EAAEX,OAAO,CAACW,QARR,oBGoCkB;AvBiClC,AGFA,AFEA,AQAA,AHDA,AYHG,AvBIH,AIAA,ADAA,AmBAA,AVAA,AbAA,A0B5DMC,A/BpBS,AkC+CmB,QH3B5BA,MAAM,EAAEZ,OAAO,CAACa,OAAR,CAAgBD,MATd;ApBsEhB,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AmBAA,AVAA,AbAA,A0B5DME,A/BrBS,AkCyDd,QHpCKA,QAAQ,EAAEd,OAAO,CAACa,OAAR,CAAgBC,QAVhB;ApBuEhB,AGFA,AFEA,AQAA,AHDA,AYHE,AvBIF,AIAA,ADAA,AmBAA,AVAA,AbAA,A0B5DMC,QFwDA1C,AExDA0C,QAAQ,EAAEf,OAAO,CAACgB,GFwDtB,CExDc,CFwDa,AExDAC,IAAb,IAAqBF,sBAXrB;ApBwEhB,AGFA,AFEA,AQAA,AHDA,AYHGjB,AvBIH,AIAA,ADAA,AmBAA,AVAA,AbAA,A0B5DMoB,MFwDHpB,EExDGoB,KFwDI,GAAG7C,CExDE,EAAE2B,OAAO,CAACgB,IAAR,CAAaG,KFwDI,AExDjB,CFwDkBvB,GExDIsB,CFwDL,CAA/B;AlBKH,AGFA,AFEA,AQAA,AHDA,AXCA,AIAA,ADAA,AmBAA,AVAA,AbAA,A0BzEgB,OAAZ,CADY,CAgBZ;ApB2DJ,AGFA,AMEA,AHDA,AYJG,AvBKH,AIAA,AkBAA,AVAA,AbAA,WwBLQ,IAAI9F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0E,OAAO,CAACxE,MAA5B,EAAoCF,CAAC,EAArC,EAAyC;AlBM5C,AGFA,AMEA,AHDA,AYJI,AvBKJ,AIAA,AkBAA,AVAA,AbAA,A0B3DI,YFsDIkD,gBAAgB,CAACpB,EEtDZ,EFsDL,CAAsB0C,EEtDZK,EFsDV,EAA4BH,AEtDvB,CAAUiB,MFsDoB,CAAC3F,CAAD,AEtDvC,CFsDI,CAAJ,AEtD6B,EFsDgB,QEtDfuE,GAAD,EAAMqB,IAAN,EAAe;ApB4DhD,AGFA,AMEA,AHDA,AYJKnB,AvBKL,AIAA,AkBAA,AVAA,AbAA,A0B3DM,QAAA,EFsDDA,EAAE,CAACC,AEtDE,CAACsB,MFsDI,CAAChG,CAAD,CAAR,CAAF,EEtDC,CFsDgBwE,EEtDI,EFsDA,CAACE,OAAO,CAAC1E,CAAD,CAAR,CAArB,gBEtDoC;ApB4DzC,AGFA,AMEA,AHDA,AYJK,AvBKL,AIAA,AkBAA,AVAA,AbAA,A0B3DQ4F,UAAAA,IAAI,EAAJA,IADiC;ApB6DzC,AGFA,AMEA,AHDA,AYJI,AvBKJ,AIAA,AkBAA,AVAA,AbAA,A0B3DQK,UAAAA,IAAI,EAAE,KAAI,CAACpB,IAAL,CAAUC;ApB4DxB,AGFA,AMEA,AHDA,AYJG,AvBKH,AIAA,AkBAA,AVAA,AbAA,A0B9DyC,SAAf,CAApB,CAD0C,CAM1C;ApB0DN,AGFA,AMEA,AHDA,AYJE,AvBKF,AIAA,AkBAA,AVAA,AbAA;AMCA,AGFA,AMEA,AHDA,AXCA,AIAA,AkBAA,AVAA,AbAA,A0B1DM,QAAA,KAAI,CAACoB,MAAL,GAAc,IAAI/H,KAAK,CAACgI,aAAV,EAAd;ApB2DN,AGFA,AMEA,AHDA,AYJC,AvBKD,AIAA,AkBAA,AVAA,AbAA,SwBLQ1B,EAAP;AlBMD,AGFA,AMEA,AHDA,AYJC,AvBKD,AIAA,AkBAA,AVAA,AbAA,A0B3DM,CF6BN,OE7BM,KAAI,CAACyB,MAAL,CAAYE,IAAZ,CAAiB,KAAI,CAACvB,IAAL,CAAUiB,SAA3B,EAAsC,UAAAZ,OAAO,EAAI;ApB4DvD,AGFA,AMEA,AHDA,AXCA,AIAA,AkBAA,AVAA,AbAA,A0B3DQ,UAAA,KAAI,CAACmB,YAAL,GAAoB,IAAIlI,KAAK,CAACmI,iBAAV,CAClB,mBAAW;ApB2DrB,AGFA,AMEA,AHDA,AXCA,AIAA,AkBAA,AVAA,AbAA,A0B1DYvC,YAAAA,GAAG,EAAEmB,OADI;ApB4DrB,AGFA,AMEA,AHDA,AXCA,AIAA,AkBAA,AVAA,AbAA,A0B1DYqB,YAAAA,IAAI,EAAEpI,KAAK,CAACqI,UAFH;ApB6DrB,AGFA,AMEA,AHDA,AXCA,AIAA,AkBAA,AVAA,AbAA,A0B1DYC,YAAAA,WAAW,EAAE,IAHJ;ApB8DrB,AGFA,AMEA,AdAA,AIAA,AkBAA,AVAA,AbAA,A0B1DYC,YAAAA,MAAM,EAAE,KAJC;ApB+DrB,AGFA,AMEA,AdAA,AIAA,AkBAA,AVAA,AbAA,A0B1DY3B,YAAAA,KAAK,EAAE,KAAI,CAACF,IAAL,CAAUE;ApB2D7B,AGFA,AMEA,AdAA,AIAA,AkBAA,AVAA,AbAA,A0BhEqB,WAAX,CADkB,CAApB;ApBkER,AGFA,AMEA,AdAA,AIAA,AkBAA,AVAA,AbAA;AMCA,AGFA,AMEA,AdAA,AIAA,AkBAA,AVAA,AbAA,A0BzDQ,UAAA,KAAI,CAAC4B,kBAAL;ApB0DR,AGFA,AMEA,AdAA,AIAA,AkBAA,AVAA,AbAA;AMCA,AGFA,AMEA,AdAA,AIAA,AkBAA,AVAA,AbAA,A0B1DQ,UAAA,KAAI,CAACC,UAAL;ApB2DR,AGFA,AMEA,AdAA,AIAA,AkBAA,AVAA,AbAA,A0B1DO,SAbD;ApBwEN,AGFA,AMEA,AdAA,AIAA,AkBAA,AVAA,AbAA,A0B1DK,OAtBD;ApBiFJ,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA,A0B1DG;ApB2DH,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA;AMCA,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA;AMCA,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA,yC0B3DuB;ApB4DvB,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA,A0B5DuB;ApB6DvB,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA;AMCA,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA,A0B7DI;ApB8DJ,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA,A0B7DI,WAAKC,EAAL,GAAU,IAAI1I,KAAK,CAAC2I,iBAAV,CAA4BrI,MAAM,CAACG,UAAnC,EAA+CH,MAAM,CAACI,WAAtD,CAAV;ApB8DJ,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA,A0B7DI,WAAKkI,QAAL,GAAgB,IAAI5I,KAAK,CAACiB,iBAAV,CAA4B,EAA5B,EAAgC,CAAhC,EAAmC,GAAnC,EAAwC,IAAxC,CAAhB;ApB8DJ,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA,A0B7DI,WAAK2H,QAAL,CAAc1H,QAAd,CAAuBC,CAAvB,GAA2B,GAA3B;ApB8DJ,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA,A0B5DI,WAAK0H,OAAL,GAAe,IAAI7I,KAAK,CAACqB,KAAV,EAAf;ApB6DJ,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA,A0B5DI,WAAKwH,OAAL,CAAaC,UAAb,GAA0B,IAAI9I,KAAK,CAAC+I,KAAV,CAAgB,KAAKrC,IAAL,CAAUG,IAA1B,CAA1B;ApB6DJ,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA,A0B3DI,WAAKiB,IAAL,GAAY,IAAI9H,KAAK,CAACgJ,IAAV,CAAe,KAAKnB,YAApB,EAAkC,KAAKK,YAAvC,CAAZ;ApB4DJ,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA;AMCA,AGFA,AMEA,AVAA,AkBAA,AVAA,AbAA,A0B5DI,kCAAKJ,IAAL,CAAU5G,QAAV,EAAmB+H,GAAnB,+CAA0B,KAAKvC,IAAL,CAAUI,YAApC;ApB6DJ,AGFA,AMEA,AVAA,AQAA,AbAA;AMCA,AGFA,AMEA,AVAA,AQAA,AbAA,A0B7DI,WAAKgB,IAAL,CAAUX,QAAV,CAAmB8B,GAAnB,CAAuB7I,IAAI,CAAC8I,EAA5B,EAAgC,CAAhC,EAAmC,CAAnC;ApB8DJ,AGFA,AMEA,AVAA,AQAA,AbAA;AMCA,AGFA,AMEA,AVAA,AQAA,AbAA,A0B9DI,+BAAKpB,IAAL,CAAUb,KAAV,EAAgBgC,GAAhB,4CAAuB,KAAKvC,IAAL,CAAUM,SAAjC;ApB+DJ,AGFA,AMEA,AVAA,ALAA;AMCA,AGFA,AMEA,AVAA,ALAA,A0B/DI,WAAK6B,OAAL,CAAaM,GAAb,CAAiB,KAAKrB,IAAtB;ApBgEJ,AGFA,AMEA,AVAA,ALAA,A0B/DG;ApBgEH,AGFA,AMEA,AVAA,ALAA;AMCA,AGFA,AMEA,AVAA,ALAA;AMCA,AGFA,AMEA,AVAA,ALAA,iC0BhEe;ApBiEf,AGFA,AMEA,AVAA,ALAA,A0BjEe;ApBkEf,AGFA,AMEA,AVAA,ALAA,A0BlEe;ApBmEf,AGFA,AMEA,AVAA,ALAA,A0BnEe;ApBoEf,AGFA,AMEA,AVAA,ALAA;AMCA,AGFA,AMEA,AVAA,ALAA,A0BpEI,WAAKV,QAAL,GAAgB,KAAKV,IAAL,CAAUU,QAA1B;ApBqEJ,AGFA,AMEA,AVAA,ALAA,A0BnEI,WAAKgC,QAAL,GAAgB,IAAIpJ,KAAK,CAACqJ,cAAV,CAAyB;ApBoE7C,AGFA,AMEA,AVAA,ALAA,A0BnEMC,QAAAA,YAAY,EAAE,KAAK5C,IAAL,CAAUW,MADe;ApBqE7C,AGFA,AMEA,AVAA,ALAA,A0BnEMkC,QAAAA,cAAc,EAAE,KAAK7C,IAAL,CAAUa,QAFa;ApBsE7C,AGFA,AMEA,AVAA,ALAA,A0BnEMiC,QAAAA,QAAQ,EAAE;ApBoEhB,AGFA,AMEA,AVAA,ALAA,A0BnEQC,UAAAA,KAAK,EAAE;ApBoEf,AGFA,AMEA,AVAA,ALAA,A0BpEiBC,YAAAA,KAAK,EAAE;ApBqExB,AGFA,AMEA,AVAA,ALAA,A0BrEe,WADC;ApBuEhB,AGFA,AMEA,AVAA,ALAA,A0BrEQC,UAAAA,QAAQ,EAAE;ApBsElB,AGFA,AMEA,AVAA,ALAA,A0BtEoBD,YAAAA,KAAK,EAAE,KAAKhB,EAAL,CAAQ3B;ApBuEnC,AGFA,AMEA,AVAA,ALAA,A0BvEkB;ApBwElB,AGFA,AMEA,AVAA,ALAA,A0B1EgB,SAH6B;ApB8E7C,AGFA,AMEA,AVAA,ALAA,A0BvEM6C,QAAAA,OAAO,EAAE;ApBwEf,AGFA,AMEA,AVAA,ALAA,A0BvEQV,UAAAA,EAAE,EAAE9I,IAAI,CAAC8I;ApBwEjB,AGFA,AMEA,AVAA,ALAA,A0BzEe,SAP8B;ApBiF7C,AGFA,AMEA,AVAA,ALAA,A0BvEM;AjBsEN,AMEA,AVAA,ALAA,A0BvEMd,QAAAA,IAAI,EAAEpI,KAAK,CAACqI;AjBsElB,AMEA,AVAA,ALAA,A0BnF6C,OAAzB,CAAhB;AjBkFJ,AMEA,AVAA,ALAA,A0BtEI,WAAKnB,IAAL,GAAY,IAAIlH,KAAK,CAACgJ,IAAV,CAAe,KAAK5B,QAApB,EAA8B,KAAKgC,QAAnC,CAAZ;AjBqEJ,AMEA,AVAA,ALAA;ASDA,AMEA,AVAA,ALAA,A0BvEI,kCAAKlC,IAAL,CAAUhG,QAAV,EAAmB+H,GAAnB,+CAA0B,KAAKvC,IAAL,CAAUxF,QAApC;AjBsEJ,AMEA,AVAA,ALAA;ASDA,AMEA,AVAA,ALAA,A0BxEI,kCAAKgG,IAAL,CAAUC,QAAV,EAAmB8B,GAAnB,+CAA0B,KAAKvC,IAAL,CAAUS,QAApC;AjBuEJ,AMEA,AfAA;ASDA,AMEA,AfAA,A0BzEI,WAAKD,IAAL,CAAU2C,MAAV,CAAiB,IAAI7J,KAAK,CAAC8J,OAAV,EAAjB;AjBwEJ,AMEA,AfAA;ASDA,AMEA,AfAA,A0BzEI,WAAK5C,IAAL,CAAU6C,cAAV,GAA2B,UAAAhK,QAAQ,EAAI;AjBwE3C,AMEA,AfAA,A0BzEMA,QAAAA,QAAQ,CAACiK,eAAT,CAAyB,MAAI,CAACtB,EAA9B;AjBwEN,AMEA,AfAA,A0BzEM3I,QAAAA,QAAQ,CAAC0B,MAAT,CAAgB,MAAI,CAACoH,OAArB,EAA8B,MAAI,CAACD,QAAnC;AjBwEN,AMEA,AfAA,A0BzEM7I,QAAAA,QAAQ,CAACiK,eAAT,CAAyB,IAAzB;AjBwEN,AMEA,AfAA,A0BzEK,OAJD;AjB4EJ,AMEA,AfAA;ASDA,AMEA,AfAA,A0BzEI,WAAKb,GAAL,CAAS,KAAKjC,IAAd;AjBwEJ,AMEA,AfAA;ASDA,AMEA,AfAA,A0BzEI+C,qBAAG7I,KAAH,CAAS+H,GAAT,CAAa,IAAb;AjBwEJ,AMEA,AfAA,A0BzEG;AjBwEH,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA,+B0B1Eae,MAAM;AjByEnB,AMEA,AfAA,A0B1EI,WAAKd,QAAL,CAAcI,QAAd,CAAuBC,KAAvB,CAA6BC,KAA7B,GAAqCQ,IAAI,GAAG,EAA5C;AjByEJ,AMEA,AfAA,A0B1EG;AjByEH,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA,E0B5K6BlK,KAAK,CAACmK;AjB2KnC,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA,AfAA;ASDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA,AMEA;ANDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"script.d573be0b.js","sourceRoot":"../src","sourcesContent":["export default new (class {\n  constructor() {\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: true,\n    })\n    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.5))\n    this.renderer.setSize(window.innerWidth, window.innerHeight)\n    this.renderer.setClearColor(0x04102f, 0)\n\n    let elWidth = window.innerWidth / 2\n    let elHeight = window.innerHeight / 2\n\n    console.log(elWidth, elHeight)\n\n    this.camera = new THREE.PerspectiveCamera(72, elWidth / elHeight, 1, 1000)\n\n    this.camera.position.z = 1\n    this.scene = new THREE.Scene()\n    this.clock = new THREE.Clock()\n\n    this.init()\n  }\n\n  render() {\n    this.renderer.render(this.scene, this.camera)\n  }\n\n  animate() {\n    requestAnimationFrame(this.animate.bind(this))\n\n    for (let i = 0; i < this.scene.children.length; i++) {\n      const obj = this.scene.children[i]\n      obj.updateTime(this.clock.getElapsedTime())\n    }\n\n    this.render()\n  }\n\n  addEvents() {\n    window.addEventListener('resize', this.resize.bind(this))\n  }\n\n  init() {\n    this.addToDom()\n    this.animate()\n    // this.addEvents()\n  }\n\n  addToDom() {\n    const canvas = this.renderer.domElement\n    const container = document.querySelector('#webgl')\n    container.appendChild(canvas)\n  }\n\n  resize() {\n    let kineticWrap = document.querySelector('.kinetic-content')\n    let width = kineticWrap.innerWidth / 2\n    let height = kineticWrap.innerHeight / 2\n\n    this.camera.aspect = width / height\n    this.camera.updateProjectionMatrix()\n    this.renderer.setSize(width, height)\n  }\n})()\n","var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n","module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  if (!fn) {\n    return false\n  }\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n","var trim = function(string) {\n  return string.replace(/^\\s+|\\s+$/g, '');\n}\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  var headersArr = trim(headers).split('\\n')\n\n  for (var i = 0; i < headersArr.length; i++) {\n    var row = headersArr[i]\n    var index = row.indexOf(':')\n    , key = trim(row.slice(0, index)).toLowerCase()\n    , value = trim(row.slice(index + 1))\n\n    if (typeof(result[key]) === 'undefined') {\n      result[key] = value\n    } else if (isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [ result[key], value ]\n    }\n  }\n\n  return result\n}\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","\"use strict\";\nvar window = require(\"global/window\")\nvar isFunction = require(\"is-function\")\nvar parseHeaders = require(\"parse-headers\")\nvar xtend = require(\"xtend\")\n\nmodule.exports = createXHR\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = \"withCredentials\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function(method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === \"string\") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === \"undefined\"){\n        throw new Error(\"callback argument missing\")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || \"GET\"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\") //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\") //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort(\"timeout\")\n            var e = new Error(\"XMLHttpRequest timeout\")\n            e.code = \"ETIMEDOUT\"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\")\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if (\"beforeSend\" in options &&\n        typeof options.beforeSend === \"function\"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n    try {\n        if (xhr.responseType === \"document\") {\n            return xhr.responseXML\n        }\n        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\"\n        if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n            return xhr.responseXML\n        }\n    } catch (e) {}\n\n    return null\n}\n\nfunction noop() {}\n","module.exports = function parseBMFontAscii(data) {\n  if (!data)\n    throw new Error('no data provided')\n  data = data.toString().trim()\n\n  var output = {\n    pages: [],\n    chars: [],\n    kernings: []\n  }\n\n  var lines = data.split(/\\r\\n?|\\n/g)\n\n  if (lines.length === 0)\n    throw new Error('no data in BMFont file')\n\n  for (var i = 0; i < lines.length; i++) {\n    var lineData = splitLine(lines[i], i)\n    if (!lineData) //skip empty lines\n      continue\n\n    if (lineData.key === 'page') {\n      if (typeof lineData.data.id !== 'number')\n        throw new Error('malformed file at line ' + i + ' -- needs page id=N')\n      if (typeof lineData.data.file !== 'string')\n        throw new Error('malformed file at line ' + i + ' -- needs page file=\"path\"')\n      output.pages[lineData.data.id] = lineData.data.file\n    } else if (lineData.key === 'chars' || lineData.key === 'kernings') {\n      //... do nothing for these two ...\n    } else if (lineData.key === 'char') {\n      output.chars.push(lineData.data)\n    } else if (lineData.key === 'kerning') {\n      output.kernings.push(lineData.data)\n    } else {\n      output[lineData.key] = lineData.data\n    }\n  }\n\n  return output\n}\n\nfunction splitLine(line, idx) {\n  line = line.replace(/\\t+/g, ' ').trim()\n  if (!line)\n    return null\n\n  var space = line.indexOf(' ')\n  if (space === -1) \n    throw new Error(\"no named row at line \" + idx)\n\n  var key = line.substring(0, space)\n\n  line = line.substring(space + 1)\n  //clear \"letter\" field as it is non-standard and\n  //requires additional complexity to parse \" / = symbols\n  line = line.replace(/letter=[\\'\\\"]\\S+[\\'\\\"]/gi, '')  \n  line = line.split(\"=\")\n  line = line.map(function(str) {\n    return str.trim().match((/(\".*?\"|[^\"\\s]+)+(?=\\s*|\\s*$)/g))\n  })\n\n  var data = []\n  for (var i = 0; i < line.length; i++) {\n    var dt = line[i]\n    if (i === 0) {\n      data.push({\n        key: dt[0],\n        data: \"\"\n      })\n    } else if (i === line.length - 1) {\n      data[data.length - 1].data = parseData(dt[0])\n    } else {\n      data[data.length - 1].data = parseData(dt[0])\n      data.push({\n        key: dt[1],\n        data: \"\"\n      })\n    }\n  }\n\n  var out = {\n    key: key,\n    data: {}\n  }\n\n  data.forEach(function(v) {\n    out.data[v.key] = v.data;\n  })\n\n  return out\n}\n\nfunction parseData(data) {\n  if (!data || data.length === 0)\n    return \"\"\n\n  if (data.indexOf('\"') === 0 || data.indexOf(\"'\") === 0)\n    return data.substring(1, data.length - 1)\n  if (data.indexOf(',') !== -1)\n    return parseIntList(data)\n  return parseInt(data, 10)\n}\n\nfunction parseIntList(data) {\n  return data.split(',').map(function(val) {\n    return parseInt(val, 10)\n  })\n}","//Some versions of GlyphDesigner have a typo\n//that causes some bugs with parsing. \n//Need to confirm with recent version of the software\n//to see whether this is still an issue or not.\nvar GLYPH_DESIGNER_ERROR = 'chasrset'\n\nmodule.exports = function parseAttributes(obj) {\n  if (GLYPH_DESIGNER_ERROR in obj) {\n    obj['charset'] = obj[GLYPH_DESIGNER_ERROR]\n    delete obj[GLYPH_DESIGNER_ERROR]\n  }\n\n  for (var k in obj) {\n    if (k === 'face' || k === 'charset') \n      continue\n    else if (k === 'padding' || k === 'spacing')\n      obj[k] = parseIntList(obj[k])\n    else\n      obj[k] = parseInt(obj[k], 10) \n  }\n  return obj\n}\n\nfunction parseIntList(data) {\n  return data.split(',').map(function(val) {\n    return parseInt(val, 10)\n  })\n}","module.exports = (function xmlparser() {\n  //common browsers\n  if (typeof self.DOMParser !== 'undefined') {\n    return function(str) {\n      var parser = new self.DOMParser()\n      return parser.parseFromString(str, 'application/xml')\n    }\n  } \n\n  //IE8 fallback\n  if (typeof self.ActiveXObject !== 'undefined'\n      && new self.ActiveXObject('Microsoft.XMLDOM')) {\n    return function(str) {\n      var xmlDoc = new self.ActiveXObject(\"Microsoft.XMLDOM\")\n      xmlDoc.async = \"false\"\n      xmlDoc.loadXML(str)\n      return xmlDoc\n    }\n  }\n\n  //last resort fallback\n  return function(str) {\n    var div = document.createElement('div')\n    div.innerHTML = str\n    return div\n  }\n})()\n","var parseAttributes = require('./parse-attribs')\nvar parseFromString = require('xml-parse-from-string')\n\n//In some cases element.attribute.nodeName can return\n//all lowercase values.. so we need to map them to the correct \n//case\nvar NAME_MAP = {\n  scaleh: 'scaleH',\n  scalew: 'scaleW',\n  stretchh: 'stretchH',\n  lineheight: 'lineHeight',\n  alphachnl: 'alphaChnl',\n  redchnl: 'redChnl',\n  greenchnl: 'greenChnl',\n  bluechnl: 'blueChnl'\n}\n\nmodule.exports = function parse(data) {\n  data = data.toString()\n  \n  var xmlRoot = parseFromString(data)\n  var output = {\n    pages: [],\n    chars: [],\n    kernings: []\n  }\n\n  //get config settings\n  ;['info', 'common'].forEach(function(key) {\n    var element = xmlRoot.getElementsByTagName(key)[0]\n    if (element)\n      output[key] = parseAttributes(getAttribs(element))\n  })\n\n  //get page info\n  var pageRoot = xmlRoot.getElementsByTagName('pages')[0]\n  if (!pageRoot)\n    throw new Error('malformed file -- no <pages> element')\n  var pages = pageRoot.getElementsByTagName('page')\n  for (var i=0; i<pages.length; i++) {\n    var p = pages[i]\n    var id = parseInt(p.getAttribute('id'), 10)\n    var file = p.getAttribute('file')\n    if (isNaN(id))\n      throw new Error('malformed file -- page \"id\" attribute is NaN')\n    if (!file)\n      throw new Error('malformed file -- needs page \"file\" attribute')\n    output.pages[parseInt(id, 10)] = file\n  }\n\n  //get kernings / chars\n  ;['chars', 'kernings'].forEach(function(key) {\n    var element = xmlRoot.getElementsByTagName(key)[0]\n    if (!element)\n      return\n    var childTag = key.substring(0, key.length-1)\n    var children = element.getElementsByTagName(childTag)\n    for (var i=0; i<children.length; i++) {      \n      var child = children[i]\n      output[key].push(parseAttributes(getAttribs(child)))\n    }\n  })\n  return output\n}\n\nfunction getAttribs(element) {\n  var attribs = getAttribList(element)\n  return attribs.reduce(function(dict, attrib) {\n    var key = mapName(attrib.nodeName)\n    dict[key] = attrib.nodeValue\n    return dict\n  }, {})\n}\n\nfunction getAttribList(element) {\n  //IE8+ and modern browsers\n  var attribs = []\n  for (var i=0; i<element.attributes.length; i++)\n    attribs.push(element.attributes[i])\n  return attribs\n}\n\nfunction mapName(nodeName) {\n  return NAME_MAP[nodeName.toLowerCase()] || nodeName\n}","var HEADER = [66, 77, 70]\n\nmodule.exports = function readBMFontBinary(buf) {\n  if (buf.length < 6)\n    throw new Error('invalid buffer length for BMFont')\n\n  var header = HEADER.every(function(byte, i) {\n    return buf.readUInt8(i) === byte\n  })\n\n  if (!header)\n    throw new Error('BMFont missing BMF byte header')\n\n  var i = 3\n  var vers = buf.readUInt8(i++)\n  if (vers > 3)\n    throw new Error('Only supports BMFont Binary v3 (BMFont App v1.10)')\n  \n  var target = { kernings: [], chars: [] }\n  for (var b=0; b<5; b++)\n    i += readBlock(target, buf, i)\n  return target\n}\n\nfunction readBlock(target, buf, i) {\n  if (i > buf.length-1)\n    return 0\n\n  var blockID = buf.readUInt8(i++)\n  var blockSize = buf.readInt32LE(i)\n  i += 4\n\n  switch(blockID) {\n    case 1: \n      target.info = readInfo(buf, i)\n      break\n    case 2:\n      target.common = readCommon(buf, i)\n      break\n    case 3:\n      target.pages = readPages(buf, i, blockSize)\n      break\n    case 4:\n      target.chars = readChars(buf, i, blockSize)\n      break\n    case 5:\n      target.kernings = readKernings(buf, i, blockSize)\n      break\n  }\n  return 5 + blockSize\n}\n\nfunction readInfo(buf, i) {\n  var info = {}\n  info.size = buf.readInt16LE(i)\n\n  var bitField = buf.readUInt8(i+2)\n  info.smooth = (bitField >> 7) & 1\n  info.unicode = (bitField >> 6) & 1\n  info.italic = (bitField >> 5) & 1\n  info.bold = (bitField >> 4) & 1\n  \n  //fixedHeight is only mentioned in binary spec \n  if ((bitField >> 3) & 1)\n    info.fixedHeight = 1\n  \n  info.charset = buf.readUInt8(i+3) || ''\n  info.stretchH = buf.readUInt16LE(i+4)\n  info.aa = buf.readUInt8(i+6)\n  info.padding = [\n    buf.readInt8(i+7),\n    buf.readInt8(i+8),\n    buf.readInt8(i+9),\n    buf.readInt8(i+10)\n  ]\n  info.spacing = [\n    buf.readInt8(i+11),\n    buf.readInt8(i+12)\n  ]\n  info.outline = buf.readUInt8(i+13)\n  info.face = readStringNT(buf, i+14)\n  return info\n}\n\nfunction readCommon(buf, i) {\n  var common = {}\n  common.lineHeight = buf.readUInt16LE(i)\n  common.base = buf.readUInt16LE(i+2)\n  common.scaleW = buf.readUInt16LE(i+4)\n  common.scaleH = buf.readUInt16LE(i+6)\n  common.pages = buf.readUInt16LE(i+8)\n  var bitField = buf.readUInt8(i+10)\n  common.packed = 0\n  common.alphaChnl = buf.readUInt8(i+11)\n  common.redChnl = buf.readUInt8(i+12)\n  common.greenChnl = buf.readUInt8(i+13)\n  common.blueChnl = buf.readUInt8(i+14)\n  return common\n}\n\nfunction readPages(buf, i, size) {\n  var pages = []\n  var text = readNameNT(buf, i)\n  var len = text.length+1\n  var count = size / len\n  for (var c=0; c<count; c++) {\n    pages[c] = buf.slice(i, i+text.length).toString('utf8')\n    i += len\n  }\n  return pages\n}\n\nfunction readChars(buf, i, blockSize) {\n  var chars = []\n\n  var count = blockSize / 20\n  for (var c=0; c<count; c++) {\n    var char = {}\n    var off = c*20\n    char.id = buf.readUInt32LE(i + 0 + off)\n    char.x = buf.readUInt16LE(i + 4 + off)\n    char.y = buf.readUInt16LE(i + 6 + off)\n    char.width = buf.readUInt16LE(i + 8 + off)\n    char.height = buf.readUInt16LE(i + 10 + off)\n    char.xoffset = buf.readInt16LE(i + 12 + off)\n    char.yoffset = buf.readInt16LE(i + 14 + off)\n    char.xadvance = buf.readInt16LE(i + 16 + off)\n    char.page = buf.readUInt8(i + 18 + off)\n    char.chnl = buf.readUInt8(i + 19 + off)\n    chars[c] = char\n  }\n  return chars\n}\n\nfunction readKernings(buf, i, blockSize) {\n  var kernings = []\n  var count = blockSize / 10\n  for (var c=0; c<count; c++) {\n    var kern = {}\n    var off = c*10\n    kern.first = buf.readUInt32LE(i + 0 + off)\n    kern.second = buf.readUInt32LE(i + 4 + off)\n    kern.amount = buf.readInt16LE(i + 8 + off)\n    kernings[c] = kern\n  }\n  return kernings\n}\n\nfunction readNameNT(buf, offset) {\n  var pos=offset\n  for (; pos<buf.length; pos++) {\n    if (buf[pos] === 0x00) \n      break\n  }\n  return buf.slice(offset, pos)\n}\n\nfunction readStringNT(buf, offset) {\n  return readNameNT(buf, offset).toString('utf8')\n}","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","var Buffer = require('buffer').Buffer; // for use with browserify\n\nmodule.exports = function (a, b) {\n    if (!Buffer.isBuffer(a)) return undefined;\n    if (!Buffer.isBuffer(b)) return undefined;\n    if (typeof a.equals === 'function') return a.equals(b);\n    if (a.length !== b.length) return false;\n    \n    for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false;\n    }\n    \n    return true;\n};\n","var equal = require('buffer-equal')\nvar HEADER = Buffer.from([66, 77, 70, 3])\n\nmodule.exports = function(buf) {\n  if (typeof buf === 'string')\n    return buf.substring(0, 3) === 'BMF'\n  return buf.length > 4 && equal(buf.slice(0, 4), HEADER)\n}","var xhr = require('xhr')\nvar noop = function(){}\nvar parseASCII = require('parse-bmfont-ascii')\nvar parseXML = require('parse-bmfont-xml')\nvar readBinary = require('parse-bmfont-binary')\nvar isBinaryFormat = require('./lib/is-binary')\nvar xtend = require('xtend')\n\nvar xml2 = (function hasXML2() {\n  return self.XMLHttpRequest && \"withCredentials\" in new XMLHttpRequest\n})()\n\nmodule.exports = function(opt, cb) {\n  cb = typeof cb === 'function' ? cb : noop\n\n  if (typeof opt === 'string')\n    opt = { uri: opt }\n  else if (!opt)\n    opt = {}\n\n  var expectBinary = opt.binary\n  if (expectBinary)\n    opt = getBinaryOpts(opt)\n\n  xhr(opt, function(err, res, body) {\n    if (err)\n      return cb(err)\n    if (!/^2/.test(res.statusCode))\n      return cb(new Error('http status code: '+res.statusCode))\n    if (!body)\n      return cb(new Error('no body result'))\n\n    var binary = false \n\n    //if the response type is an array buffer,\n    //we need to convert it into a regular Buffer object\n    if (isArrayBuffer(body)) {\n      var array = new Uint8Array(body)\n      body = Buffer.from(array, 'binary')\n    }\n\n    //now check the string/Buffer response\n    //and see if it has a binary BMF header\n    if (isBinaryFormat(body)) {\n      binary = true\n      //if we have a string, turn it into a Buffer\n      if (typeof body === 'string') \n        body = Buffer.from(body, 'binary')\n    } \n\n    //we are not parsing a binary format, just ASCII/XML/etc\n    if (!binary) {\n      //might still be a buffer if responseType is 'arraybuffer'\n      if (Buffer.isBuffer(body))\n        body = body.toString(opt.encoding)\n      body = body.trim()\n    }\n\n    var result\n    try {\n      var type = res.headers['content-type']\n      if (binary)\n        result = readBinary(body)\n      else if (/json/.test(type) || body.charAt(0) === '{')\n        result = JSON.parse(body)\n      else if (/xml/.test(type)  || body.charAt(0) === '<')\n        result = parseXML(body)\n      else\n        result = parseASCII(body)\n    } catch (e) {\n      cb(new Error('error parsing font '+e.message))\n      cb = noop\n    }\n    cb(null, result)\n  })\n}\n\nfunction isArrayBuffer(arr) {\n  var str = Object.prototype.toString\n  return str.call(arr) === '[object ArrayBuffer]'\n}\n\nfunction getBinaryOpts(opt) {\n  //IE10+ and other modern browsers support array buffers\n  if (xml2)\n    return xtend(opt, { responseType: 'arraybuffer' })\n  \n  if (typeof self.XMLHttpRequest === 'undefined')\n    throw new Error('your browser does not support XHR loading')\n\n  //IE9 and XML1 browsers could still use an override\n  var req = new self.XMLHttpRequest()\n  req.overrideMimeType('text/plain; charset=x-user-defined')\n  return xtend({\n    xhr: req\n  }, opt)\n}\n","var newline = /\\n/\nvar newlineChar = '\\n'\nvar whitespace = /\\s/\n\nmodule.exports = function(text, opt) {\n    var lines = module.exports.lines(text, opt)\n    return lines.map(function(line) {\n        return text.substring(line.start, line.end)\n    }).join('\\n')\n}\n\nmodule.exports.lines = function wordwrap(text, opt) {\n    opt = opt||{}\n\n    //zero width results in nothing visible\n    if (opt.width === 0 && opt.mode !== 'nowrap') \n        return []\n\n    text = text||''\n    var width = typeof opt.width === 'number' ? opt.width : Number.MAX_VALUE\n    var start = Math.max(0, opt.start||0)\n    var end = typeof opt.end === 'number' ? opt.end : text.length\n    var mode = opt.mode\n\n    var measure = opt.measure || monospace\n    if (mode === 'pre')\n        return pre(measure, text, start, end, width)\n    else\n        return greedy(measure, text, start, end, width, mode)\n}\n\nfunction idxOf(text, chr, start, end) {\n    var idx = text.indexOf(chr, start)\n    if (idx === -1 || idx > end)\n        return end\n    return idx\n}\n\nfunction isWhitespace(chr) {\n    return whitespace.test(chr)\n}\n\nfunction pre(measure, text, start, end, width) {\n    var lines = []\n    var lineStart = start\n    for (var i=start; i<end && i<text.length; i++) {\n        var chr = text.charAt(i)\n        var isNewline = newline.test(chr)\n\n        //If we've reached a newline, then step down a line\n        //Or if we've reached the EOF\n        if (isNewline || i===end-1) {\n            var lineEnd = isNewline ? i : i+1\n            var measured = measure(text, lineStart, lineEnd, width)\n            lines.push(measured)\n            \n            lineStart = i+1\n        }\n    }\n    return lines\n}\n\nfunction greedy(measure, text, start, end, width, mode) {\n    //A greedy word wrapper based on LibGDX algorithm\n    //https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java\n    var lines = []\n\n    var testWidth = width\n    //if 'nowrap' is specified, we only wrap on newline chars\n    if (mode === 'nowrap')\n        testWidth = Number.MAX_VALUE\n\n    while (start < end && start < text.length) {\n        //get next newline position\n        var newLine = idxOf(text, newlineChar, start, end)\n\n        //eat whitespace at start of line\n        while (start < newLine) {\n            if (!isWhitespace( text.charAt(start) ))\n                break\n            start++\n        }\n\n        //determine visible # of glyphs for the available width\n        var measured = measure(text, start, newLine, testWidth)\n\n        var lineEnd = start + (measured.end-measured.start)\n        var nextStart = lineEnd + newlineChar.length\n\n        //if we had to cut the line before the next newline...\n        if (lineEnd < newLine) {\n            //find char to break on\n            while (lineEnd > start) {\n                if (isWhitespace(text.charAt(lineEnd)))\n                    break\n                lineEnd--\n            }\n            if (lineEnd === start) {\n                if (nextStart > start + newlineChar.length) nextStart--\n                lineEnd = nextStart // If no characters to break, show all.\n            } else {\n                nextStart = lineEnd\n                //eat whitespace at end of line\n                while (lineEnd > start) {\n                    if (!isWhitespace(text.charAt(lineEnd - newlineChar.length)))\n                        break\n                    lineEnd--\n                }\n            }\n        }\n        if (lineEnd >= start) {\n            var result = measure(text, start, lineEnd, testWidth)\n            lines.push(result)\n        }\n        start = nextStart\n    }\n    return lines\n}\n\n//determines the visible number of glyphs within a given width\nfunction monospace(text, start, end, width) {\n    var glyphs = Math.min(width, end-start)\n    return {\n        start: start,\n        end: start+glyphs\n    }\n}","module.exports = function numtype(num, def) {\n\treturn typeof num === 'number'\n\t\t? num \n\t\t: (typeof def === 'number' ? def : 0)\n}","var wordWrap = require('word-wrapper')\nvar xtend = require('xtend')\nvar number = require('as-number')\n\nvar X_HEIGHTS = ['x', 'e', 'a', 'o', 'n', 's', 'r', 'c', 'u', 'm', 'v', 'w', 'z']\nvar M_WIDTHS = ['m', 'w']\nvar CAP_HEIGHTS = ['H', 'I', 'N', 'E', 'F', 'K', 'L', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n\n\nvar TAB_ID = '\\t'.charCodeAt(0)\nvar SPACE_ID = ' '.charCodeAt(0)\nvar ALIGN_LEFT = 0, \n    ALIGN_CENTER = 1, \n    ALIGN_RIGHT = 2\n\nmodule.exports = function createLayout(opt) {\n  return new TextLayout(opt)\n}\n\nfunction TextLayout(opt) {\n  this.glyphs = []\n  this._measure = this.computeMetrics.bind(this)\n  this.update(opt)\n}\n\nTextLayout.prototype.update = function(opt) {\n  opt = xtend({\n    measure: this._measure\n  }, opt)\n  this._opt = opt\n  this._opt.tabSize = number(this._opt.tabSize, 4)\n\n  if (!opt.font)\n    throw new Error('must provide a valid bitmap font')\n\n  var glyphs = this.glyphs\n  var text = opt.text||'' \n  var font = opt.font\n  this._setupSpaceGlyphs(font)\n  \n  var lines = wordWrap.lines(text, opt)\n  var minWidth = opt.width || 0\n\n  //clear glyphs\n  glyphs.length = 0\n\n  //get max line width\n  var maxLineWidth = lines.reduce(function(prev, line) {\n    return Math.max(prev, line.width, minWidth)\n  }, 0)\n\n  //the pen position\n  var x = 0\n  var y = 0\n  var lineHeight = number(opt.lineHeight, font.common.lineHeight)\n  var baseline = font.common.base\n  var descender = lineHeight-baseline\n  var letterSpacing = opt.letterSpacing || 0\n  var height = lineHeight * lines.length - descender\n  var align = getAlignType(this._opt.align)\n\n  //draw text along baseline\n  y -= height\n  \n  //the metrics for this text layout\n  this._width = maxLineWidth\n  this._height = height\n  this._descender = lineHeight - baseline\n  this._baseline = baseline\n  this._xHeight = getXHeight(font)\n  this._capHeight = getCapHeight(font)\n  this._lineHeight = lineHeight\n  this._ascender = lineHeight - descender - this._xHeight\n    \n  //layout each glyph\n  var self = this\n  lines.forEach(function(line, lineIndex) {\n    var start = line.start\n    var end = line.end\n    var lineWidth = line.width\n    var lastGlyph\n    \n    //for each glyph in that line...\n    for (var i=start; i<end; i++) {\n      var id = text.charCodeAt(i)\n      var glyph = self.getGlyph(font, id)\n      if (glyph) {\n        if (lastGlyph) \n          x += getKerning(font, lastGlyph.id, glyph.id)\n\n        var tx = x\n        if (align === ALIGN_CENTER) \n          tx += (maxLineWidth-lineWidth)/2\n        else if (align === ALIGN_RIGHT)\n          tx += (maxLineWidth-lineWidth)\n\n        glyphs.push({\n          position: [tx, y],\n          data: glyph,\n          index: i,\n          line: lineIndex\n        })  \n\n        //move pen forward\n        x += glyph.xadvance + letterSpacing\n        lastGlyph = glyph\n      }\n    }\n\n    //next line down\n    y += lineHeight\n    x = 0\n  })\n  this._linesTotal = lines.length;\n}\n\nTextLayout.prototype._setupSpaceGlyphs = function(font) {\n  //These are fallbacks, when the font doesn't include\n  //' ' or '\\t' glyphs\n  this._fallbackSpaceGlyph = null\n  this._fallbackTabGlyph = null\n\n  if (!font.chars || font.chars.length === 0)\n    return\n\n  //try to get space glyph\n  //then fall back to the 'm' or 'w' glyphs\n  //then fall back to the first glyph available\n  var space = getGlyphById(font, SPACE_ID) \n          || getMGlyph(font) \n          || font.chars[0]\n\n  //and create a fallback for tab\n  var tabWidth = this._opt.tabSize * space.xadvance\n  this._fallbackSpaceGlyph = space\n  this._fallbackTabGlyph = xtend(space, {\n    x: 0, y: 0, xadvance: tabWidth, id: TAB_ID, \n    xoffset: 0, yoffset: 0, width: 0, height: 0\n  })\n}\n\nTextLayout.prototype.getGlyph = function(font, id) {\n  var glyph = getGlyphById(font, id)\n  if (glyph)\n    return glyph\n  else if (id === TAB_ID) \n    return this._fallbackTabGlyph\n  else if (id === SPACE_ID) \n    return this._fallbackSpaceGlyph\n  return null\n}\n\nTextLayout.prototype.computeMetrics = function(text, start, end, width) {\n  var letterSpacing = this._opt.letterSpacing || 0\n  var font = this._opt.font\n  var curPen = 0\n  var curWidth = 0\n  var count = 0\n  var glyph\n  var lastGlyph\n\n  if (!font.chars || font.chars.length === 0) {\n    return {\n      start: start,\n      end: start,\n      width: 0\n    }\n  }\n\n  end = Math.min(text.length, end)\n  for (var i=start; i < end; i++) {\n    var id = text.charCodeAt(i)\n    var glyph = this.getGlyph(font, id)\n\n    if (glyph) {\n      //move pen forward\n      var xoff = glyph.xoffset\n      var kern = lastGlyph ? getKerning(font, lastGlyph.id, glyph.id) : 0\n      curPen += kern\n\n      var nextPen = curPen + glyph.xadvance + letterSpacing\n      var nextWidth = curPen + glyph.width\n\n      //we've hit our limit; we can't move onto the next glyph\n      if (nextWidth >= width || nextPen >= width)\n        break\n\n      //otherwise continue along our line\n      curPen = nextPen\n      curWidth = nextWidth\n      lastGlyph = glyph\n    }\n    count++\n  }\n  \n  //make sure rightmost edge lines up with rendered glyphs\n  if (lastGlyph)\n    curWidth += lastGlyph.xoffset\n\n  return {\n    start: start,\n    end: start + count,\n    width: curWidth\n  }\n}\n\n//getters for the private vars\n;['width', 'height', \n  'descender', 'ascender',\n  'xHeight', 'baseline',\n  'capHeight',\n  'lineHeight' ].forEach(addGetter)\n\nfunction addGetter(name) {\n  Object.defineProperty(TextLayout.prototype, name, {\n    get: wrapper(name),\n    configurable: true\n  })\n}\n\n//create lookups for private vars\nfunction wrapper(name) {\n  return (new Function([\n    'return function '+name+'() {',\n    '  return this._'+name,\n    '}'\n  ].join('\\n')))()\n}\n\nfunction getGlyphById(font, id) {\n  if (!font.chars || font.chars.length === 0)\n    return null\n\n  var glyphIdx = findChar(font.chars, id)\n  if (glyphIdx >= 0)\n    return font.chars[glyphIdx]\n  return null\n}\n\nfunction getXHeight(font) {\n  for (var i=0; i<X_HEIGHTS.length; i++) {\n    var id = X_HEIGHTS[i].charCodeAt(0)\n    var idx = findChar(font.chars, id)\n    if (idx >= 0) \n      return font.chars[idx].height\n  }\n  return 0\n}\n\nfunction getMGlyph(font) {\n  for (var i=0; i<M_WIDTHS.length; i++) {\n    var id = M_WIDTHS[i].charCodeAt(0)\n    var idx = findChar(font.chars, id)\n    if (idx >= 0) \n      return font.chars[idx]\n  }\n  return 0\n}\n\nfunction getCapHeight(font) {\n  for (var i=0; i<CAP_HEIGHTS.length; i++) {\n    var id = CAP_HEIGHTS[i].charCodeAt(0)\n    var idx = findChar(font.chars, id)\n    if (idx >= 0) \n      return font.chars[idx].height\n  }\n  return 0\n}\n\nfunction getKerning(font, left, right) {\n  if (!font.kernings || font.kernings.length === 0)\n    return 0\n\n  var table = font.kernings\n  for (var i=0; i<table.length; i++) {\n    var kern = table[i]\n    if (kern.first === left && kern.second === right)\n      return kern.amount\n  }\n  return 0\n}\n\nfunction getAlignType(align) {\n  if (align === 'center')\n    return ALIGN_CENTER\n  else if (align === 'right')\n    return ALIGN_RIGHT\n  return ALIGN_LEFT\n}\n\nfunction findChar (array, value, start) {\n  start = start || 0\n  for (var i = start; i < array.length; i++) {\n    if (array[i].id === value) {\n      return i\n    }\n  }\n  return -1\n}","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","module.exports = function(dtype) {\n  switch (dtype) {\n    case 'int8':\n      return Int8Array\n    case 'int16':\n      return Int16Array\n    case 'int32':\n      return Int32Array\n    case 'uint8':\n      return Uint8Array\n    case 'uint16':\n      return Uint16Array\n    case 'uint32':\n      return Uint32Array\n    case 'float32':\n      return Float32Array\n    case 'float64':\n      return Float64Array\n    case 'array':\n      return Array\n    case 'uint8_clamped':\n      return Uint8ClampedArray\n  }\n}\n","var str = Object.prototype.toString\n\nmodule.exports = anArray\n\nfunction anArray(arr) {\n  return (\n       arr.BYTES_PER_ELEMENT\n    && str.call(arr.buffer) === '[object ArrayBuffer]'\n    || Array.isArray(arr)\n  )\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","var dtype = require('dtype')\nvar anArray = require('an-array')\nvar isBuffer = require('is-buffer')\n\nvar CW = [0, 2, 3]\nvar CCW = [2, 1, 3]\n\nmodule.exports = function createQuadElements(array, opt) {\n    //if user didn't specify an output array\n    if (!array || !(anArray(array) || isBuffer(array))) {\n        opt = array || {}\n        array = null\n    }\n\n    if (typeof opt === 'number') //backwards-compatible\n        opt = { count: opt }\n    else\n        opt = opt || {}\n\n    var type = typeof opt.type === 'string' ? opt.type : 'uint16'\n    var count = typeof opt.count === 'number' ? opt.count : 1\n    var start = (opt.start || 0) \n\n    var dir = opt.clockwise !== false ? CW : CCW,\n        a = dir[0], \n        b = dir[1],\n        c = dir[2]\n\n    var numIndices = count * 6\n\n    var indices = array || new (dtype(type))(numIndices)\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {\n        var x = i + start\n        indices[x + 0] = j + 0\n        indices[x + 1] = j + 1\n        indices[x + 2] = j + 2\n        indices[x + 3] = j + a\n        indices[x + 4] = j + b\n        indices[x + 5] = j + c\n    }\n    return indices\n}","module.exports.pages = function pages (glyphs) {\n  var pages = new Float32Array(glyphs.length * 4 * 1)\n  var i = 0\n  glyphs.forEach(function (glyph) {\n    var id = glyph.data.page || 0\n    pages[i++] = id\n    pages[i++] = id\n    pages[i++] = id\n    pages[i++] = id\n  })\n  return pages\n}\n\nmodule.exports.uvs = function uvs (glyphs, texWidth, texHeight, flipY) {\n  var uvs = new Float32Array(glyphs.length * 4 * 2)\n  var i = 0\n  glyphs.forEach(function (glyph) {\n    var bitmap = glyph.data\n    var bw = (bitmap.x + bitmap.width)\n    var bh = (bitmap.y + bitmap.height)\n\n    // top left position\n    var u0 = bitmap.x / texWidth\n    var v1 = bitmap.y / texHeight\n    var u1 = bw / texWidth\n    var v0 = bh / texHeight\n\n    if (flipY) {\n      v1 = (texHeight - bitmap.y) / texHeight\n      v0 = (texHeight - bh) / texHeight\n    }\n\n    // BL\n    uvs[i++] = u0\n    uvs[i++] = v1\n    // TL\n    uvs[i++] = u0\n    uvs[i++] = v0\n    // TR\n    uvs[i++] = u1\n    uvs[i++] = v0\n    // BR\n    uvs[i++] = u1\n    uvs[i++] = v1\n  })\n  return uvs\n}\n\nmodule.exports.positions = function positions (glyphs) {\n  var positions = new Float32Array(glyphs.length * 4 * 2)\n  var i = 0\n  glyphs.forEach(function (glyph) {\n    var bitmap = glyph.data\n\n    // bottom left position\n    var x = glyph.position[0] + bitmap.xoffset\n    var y = glyph.position[1] + bitmap.yoffset\n\n    // quad size\n    var w = bitmap.width\n    var h = bitmap.height\n\n    // BL\n    positions[i++] = x\n    positions[i++] = y\n    // TL\n    positions[i++] = x\n    positions[i++] = y + h\n    // TR\n    positions[i++] = x + w\n    positions[i++] = y + h\n    // BR\n    positions[i++] = x + w\n    positions[i++] = y\n  })\n  return positions\n}\n","var itemSize = 2\nvar box = { min: [0, 0], max: [0, 0] }\n\nfunction bounds (positions) {\n  var count = positions.length / itemSize\n  box.min[0] = positions[0]\n  box.min[1] = positions[1]\n  box.max[0] = positions[0]\n  box.max[1] = positions[1]\n\n  for (var i = 0; i < count; i++) {\n    var x = positions[i * itemSize + 0]\n    var y = positions[i * itemSize + 1]\n    box.min[0] = Math.min(x, box.min[0])\n    box.min[1] = Math.min(y, box.min[1])\n    box.max[0] = Math.max(x, box.max[0])\n    box.max[1] = Math.max(y, box.max[1])\n  }\n}\n\nmodule.exports.computeBox = function (positions, output) {\n  bounds(positions)\n  output.min.set(box.min[0], box.min[1], 0)\n  output.max.set(box.max[0], box.max[1], 0)\n}\n\nmodule.exports.computeSphere = function (positions, output) {\n  bounds(positions)\n  var minX = box.min[0]\n  var minY = box.min[1]\n  var maxX = box.max[0]\n  var maxY = box.max[1]\n  var width = maxX - minX\n  var height = maxY - minY\n  var length = Math.sqrt(width * width + height * height)\n  output.center.set(minX + width / 2, minY + height / 2, 0)\n  output.radius = length / 2\n}\n","var createLayout = require('layout-bmfont-text')\nvar inherits = require('inherits')\nvar createIndices = require('quad-indices')\n\nvar vertices = require('./lib/vertices')\nvar utils = require('./lib/utils')\n\nvar Base = THREE.BufferGeometry\n\nmodule.exports = function createTextGeometry (opt) {\n  return new TextGeometry(opt)\n}\n\nfunction TextGeometry (opt) {\n  Base.call(this)\n\n  if (typeof opt === 'string') {\n    opt = { text: opt }\n  }\n\n  // use these as default values for any subsequent\n  // calls to update()\n  this._opt = Object.assign({}, opt)\n\n  // also do an initial setup...\n  if (opt) this.update(opt)\n}\n\ninherits(TextGeometry, Base)\n\nTextGeometry.prototype.update = function (opt) {\n  if (typeof opt === 'string') {\n    opt = { text: opt }\n  }\n\n  // use constructor defaults\n  opt = Object.assign({}, this._opt, opt)\n\n  if (!opt.font) {\n    throw new TypeError('must specify a { font } in options')\n  }\n\n  this.layout = createLayout(opt)\n\n  // get vec2 texcoords\n  var flipY = opt.flipY !== false\n\n  // the desired BMFont data\n  var font = opt.font\n\n  // determine texture size from font file\n  var texWidth = font.common.scaleW\n  var texHeight = font.common.scaleH\n\n  // get visible glyphs\n  var glyphs = this.layout.glyphs.filter(function (glyph) {\n    var bitmap = glyph.data\n    return bitmap.width * bitmap.height > 0\n  })\n\n  // provide visible glyphs for convenience\n  this.visibleGlyphs = glyphs\n\n  // get common vertex data\n  var positions = vertices.positions(glyphs)\n  var uvs = vertices.uvs(glyphs, texWidth, texHeight, flipY)\n  var indices = createIndices([], {\n    clockwise: true,\n    type: 'uint16',\n    count: glyphs.length\n  })\n\n  // update vertex data\n  this.setIndex(indices)\n  this.setAttribute('position', new THREE.BufferAttribute(positions, 2))\n  this.setAttribute('uv', new THREE.BufferAttribute(uvs, 2))\n\n  // update multipage data\n  if (!opt.multipage && 'page' in this.attributes) {\n    // disable multipage rendering\n    this.removeAttribute('page')\n  } else if (opt.multipage) {\n    // enable multipage rendering\n    var pages = vertices.pages(glyphs)\n    this.setAttribute('page', new THREE.BufferAttribute(pages, 1))\n  }\n}\n\nTextGeometry.prototype.computeBoundingSphere = function () {\n  if (this.boundingSphere === null) {\n    this.boundingSphere = new THREE.Sphere()\n  }\n\n  var positions = this.attributes.position.array\n  var itemSize = this.attributes.position.itemSize\n  if (!positions || !itemSize || positions.length < 2) {\n    this.boundingSphere.radius = 0\n    this.boundingSphere.center.set(0, 0, 0)\n    return\n  }\n  utils.computeSphere(positions, this.boundingSphere)\n  if (isNaN(this.boundingSphere.radius)) {\n    console.error('THREE.BufferGeometry.computeBoundingSphere(): ' +\n      'Computed radius is NaN. The ' +\n      '\"position\" attribute is likely to have NaN values.')\n  }\n}\n\nTextGeometry.prototype.computeBoundingBox = function () {\n  if (this.boundingBox === null) {\n    this.boundingBox = new THREE.Box3()\n  }\n\n  var bbox = this.boundingBox\n  var positions = this.attributes.position.array\n  var itemSize = this.attributes.position.itemSize\n  if (!positions || !itemSize || positions.length < 2) {\n    bbox.makeEmpty()\n    return\n  }\n  utils.computeBox(positions, bbox)\n}\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","var assign = require('object-assign');\n\nmodule.exports = function createMSDFShader (opt) {\n  opt = opt || {};\n  var opacity = typeof opt.opacity === 'number' ? opt.opacity : 1;\n  var alphaTest = typeof opt.alphaTest === 'number' ? opt.alphaTest : 0.0001;\n  var precision = opt.precision || 'highp';\n  var color = opt.color;\n  var map = opt.map;\n  var negate = typeof opt.negate === 'boolean' ? opt.negate : true;\n\n  // remove to satisfy r73\n  delete opt.map;\n  delete opt.color;\n  delete opt.precision;\n  delete opt.opacity;\n  delete opt.negate;\n\n  return assign({\n    uniforms: {\n      opacity: { type: 'f', value: opacity },\n      map: { type: 't', value: map || new THREE.Texture() },\n      color: { type: 'c', value: new THREE.Color(color) }\n    },\n    vertexShader: [\n      'attribute vec2 uv;',\n      'attribute vec4 position;',\n      'uniform mat4 projectionMatrix;',\n      'uniform mat4 modelViewMatrix;',\n      'varying vec2 vUv;',\n      'void main() {',\n      'vUv = uv;',\n      'gl_Position = projectionMatrix * modelViewMatrix * position;',\n      '}'\n    ].join('\\n'),\n    fragmentShader: [\n      '#ifdef GL_OES_standard_derivatives',\n      '#extension GL_OES_standard_derivatives : enable',\n      '#endif',\n      'precision ' + precision + ' float;',\n      'uniform float opacity;',\n      'uniform vec3 color;',\n      'uniform sampler2D map;',\n      'varying vec2 vUv;',\n\n      'float median(float r, float g, float b) {',\n      '  return max(min(r, g), min(max(r, g), b));',\n      '}',\n\n      'void main() {',\n      '  vec3 sample = ' + (negate ? '1.0 - ' : '') + 'texture2D(map, vUv).rgb;',\n      '  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;',\n      '  float alpha = clamp(sigDist/fwidth(sigDist) + 0.5, 0.0, 1.0);',\n      '  gl_FragColor = vec4(color.xyz, alpha * opacity);',\n      alphaTest === 0\n        ? ''\n        : '  if (gl_FragColor.a < ' + alphaTest + ') discard;',\n      '}'\n    ].join('\\n')\n  }, opt);\n};\n","import Gl from './index'\n\n// THREE BMFONT TEXT\nimport loadFont from 'load-bmfont'\nimport createGeometry from 'three-bmfont-text'\nimport MSDFShader from 'three-bmfont-text/shaders/msdf'\nimport fontFile from '../../assets/Orbitron-Black.fnt'\nimport fontAtlas from '../../assets/Orbitron-Black.png'\n\nexport default class extends THREE.Object3D {\n  init(options) {\n    this.opts = {\n      word: options.word,\n      color: options.color,\n      fill: options.fill,\n      wordPosition: options.position.texture,\n      wordScale: options.scale,\n      position: options.position.mesh,\n      rotation: options.rotation || [0, 0, 0],\n      geometry: options.geometry,\n      vertex: options.shaders.vertex,\n      fragment: options.shaders.fragment,\n      fontFile: options.font.file || fontFile,\n      fontAtlas: options.font.atlas || fontAtlas,\n    }\n\n    // Create geometry of packed glyphs\n    loadFont(this.opts.fontFile, (err, font) => {\n      this.fontGeometry = createGeometry({\n        font,\n        text: this.opts.word,\n      })\n\n      // Load texture containing font glyps\n      this.loader = new THREE.TextureLoader()\n      this.loader.load(this.opts.fontAtlas, texture => {\n        this.fontMaterial = new THREE.RawShaderMaterial(\n          MSDFShader({\n            map: texture,\n            side: THREE.DoubleSide,\n            transparent: true,\n            negate: false,\n            color: this.opts.color,\n          }),\n        )\n\n        this.createRenderTarget()\n        this.createMesh()\n      })\n    })\n  }\n\n  createRenderTarget() {\n    // Render Target setup\n    this.rt = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight)\n    this.rtCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000)\n    this.rtCamera.position.z = 2.4\n\n    this.rtScene = new THREE.Scene()\n    this.rtScene.background = new THREE.Color(this.opts.fill)\n\n    this.text = new THREE.Mesh(this.fontGeometry, this.fontMaterial)\n    this.text.position.set(...this.opts.wordPosition)\n    this.text.rotation.set(Math.PI, 0, 0)\n    this.text.scale.set(...this.opts.wordScale)\n    this.rtScene.add(this.text)\n  }\n\n  createMesh() {\n    this.geometry = this.opts.geometry\n\n    this.material = new THREE.ShaderMaterial({\n      vertexShader: this.opts.vertex,\n      fragmentShader: this.opts.fragment,\n      uniforms: {\n        uTime: { value: 0 },\n        uTexture: { value: this.rt.texture },\n      },\n      defines: {\n        PI: Math.PI,\n      },\n      // wireframe: true,\n      side: THREE.DoubleSide,\n    })\n\n    this.mesh = new THREE.Mesh(this.geometry, this.material)\n    this.mesh.position.set(...this.opts.position)\n    this.mesh.rotation.set(...this.opts.rotation)\n    this.mesh.lookAt(new THREE.Vector3())\n\n    this.mesh.onBeforeRender = renderer => {\n      renderer.setRenderTarget(this.rt)\n      renderer.render(this.rtScene, this.rtCamera)\n      renderer.setRenderTarget(null)\n    }\n\n    this.add(this.mesh)\n\n    Gl.scene.add(this)\n  }\n\n  updateTime(time) {\n    this.material.uniforms.uTime.value = time / 17\n  }\n}\n","//----------------- TORUS KNOT SHADERS -----------------//\n\nconst torusVertex = /* glsl */ `\n  varying vec2 vUv;\n  varying vec3 vPosition;\n\n  uniform float uTime;\n\n  void main() {\n    vUv = uv;\n    vPosition = position;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n  }\n`\n\nconst torusFragment = /* glsl */ `\n  varying vec2 vUv;\n  varying vec3 vPosition;\n\n  uniform float uTime;\n  uniform sampler2D uTexture;\n\n  void main() {\n    float time = uTime * 0.4;\n\n    vec2 repeat = -vec2(12., 3.);\n    vec2 uv = fract(vUv * repeat - vec2(time, 0.));\n    vec3 texture = texture2D(uTexture, uv).rgb;\n    // texture *= vec3(uv.x, uv.y, 0.);\n\n    float fog = clamp(vPosition.z / 0., 0.7, 1.);\n    vec3 fragColor = mix(vec3(0.), texture, fog);\n\n    gl_FragColor = vec4(fragColor, 1.);\n  }\n`\n\nexport default { torusVertex, torusFragment }\n","import shaders from './shaders'\nimport fontFile from '../../assets/Orbitron-Black.fnt'\nimport fontAtlas from '../../assets/Orbitron-Black.png'\n\nconst options = [\n  {\n    word: 'IT FEST',\n    color: '#1D2F5D',\n    fill: '#04102f',\n    geometry: new THREE.TorusKnotGeometry(9, 3, 768, 3, 4, 3),\n    position: {\n      texture: [-0.965, -0.4, 0],\n      mesh: [0, 0, 0],\n    },\n    scale: [0.01, 0.05, 1],\n    shaders: {\n      vertex: shaders.torusVertex,\n      fragment: shaders.torusFragment,\n    },\n    font: {\n      file: fontFile,\n      atlas: fontAtlas,\n    },\n  },\n]\n\nexport default options\n","// var s = skrollr.init({\n//   render: function(data) {\n//     jQuery('.hero-title').text(Math.round(data.curTop))\n//   },\n// })\n\n/* Kinetic Typography with Three.js \nto render kinetic 3D typography - start script */\n\nimport Type from './kinetic/Type'\nimport options from './kinetic/options'\nclass App {\n  constructor() {\n    this.init()\n  }\n\n  init() {\n    this.createGl()\n  }\n\n  createGl() {\n    for (let i = 0; i < options.length; i++) {\n      // Position elements in a circle\n      let angle = (i / options.length) * (Math.PI * 2) + Math.PI * 1.5 // Offset the turn\n      let radius = 50\n      let x = radius * Math.cos(angle)\n      let z = radius * Math.sin(angle)\n      options[i].position.mesh = [x, 0, z]\n\n      // Create kinetic type\n      let type = new Type()\n      type.init(options[i])\n    }\n  }\n}\n\nnew App()\n\n/* Buttom animation */\n$('.js-btn--fly').click(function() {\n  $(this).toggleClass('clicked')\n})\n\n/*  Smooth Scroll */\n\nconst smoothAnchors = document.querySelectorAll('.menu-link')\n\nfor (let anchor of smoothAnchors) {\n  anchor.addEventListener('click', function(e) {\n    e.preventDefault()\n    const anchorID = anchor.getAttribute('href')\n\n    document.querySelector(anchorID).scrollIntoView({\n      top: 50,\n      behavior: 'smooth',\n    })\n  })\n}\n"]}